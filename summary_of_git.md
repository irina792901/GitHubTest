# Что такое git

***Git** - это **программа, контролирующая  версит** проекта, в которой фик   сируются изменения в файле. Позволяет хранить и возвращаться к версиям проекта всем участникам*

Создатель Линус Торвальдс, фино-американский программист.
 
## Как устрановить Git на компьютер.
Нужно скачать и установить: 

https://git-scm.com/book/ru/v2/Введение-Установка-Git

https://code.visualstudio.com/

редактором по умолчанию в Visual Studio Code является vim/ Но при желании можно установить любой (Notepad, Sublimtext). При этом можно прописать путь до файла exe, можно и просто указав название:

* git config --global core.editor "notepad"

* git config --global core.editor 
*git config --global core.editor "'C:/Program Files (x86)/sublime text 3/subl.exe' -w"

## Vim (некоторые основные команды, о которых можно прочитать в туториале vim):

ESC     — переход в командный режим

i       — переход в режим редактирования текста

ZQ (зажат Shift, поочередное нажатие) — выход без сохранения

ZZ (зажат Shift, поочередное нажатие) — сохранить и выйти

:q!             — выйти без сохранения

:wq             — сохранить файл и выйти

:w filename.txt — сохранить файл как filename.txt

пути прописываются при помощи /

cd означает каталог (chang disk)

cd название папки - и мы в папке (это очень нужно при клонировании репозитория)

точка означает текущий каталог

2 точки - команда переместиться по каталогу выше

пробел можно заэкранировать, спрятав "Program files" в кавычки или обратным слэшем перед пробелом

Одна из самых используемых комад - это нажатие кнопки Tab даёт автопродление 

pwd - опередляет в каком каталоге мы находимся

ls - листинг каталога за исключением файлов с первым знаком в названии у которых точка (игнорируемые файлы в дальнейшем)

ls -a позволяет "увидеть" и такие файлы

mkdir создает каталог

mv tmp temp переименовывает/перемещает файлы 

rm <название файла с расширением> удаляет файл

rm -rf temp удалляет непустой каталог (r означает рекурсивно, f означает не спрашивая подтверждения)

## Что такое репозиторий

Репозиторий - это скрытая папка с расширением .git, в которой хранятся все изменения в версиях файла. 
Создается командой git init   


## Начальное знакомство с командами git

Первостепенные команды после установки Git на компьтер:

**git config --global user.name "Name"**

**git config --global user.email** 

После указания своих данных, можно их просмотреть:

**git config --global --list**

Чтобы изменить имя main для вашей ветки по умолчанию, выполните следующую команду:

**git config --global init.defaultBranch main**
Имя главной ветки может быть любым, но для оптимизации работы есть правила хорошего тона которые следуетс соблюдать в зависимости от требований и желаний участников рабочего процесса... Так например, с 2020 года GitHub выступает за то, чтобы главная ветка называлась main (по политическим причинам) и настоятельно рекомендует переименовать ветку

Инициализация репозитория:
Создать пустой репозиторий Git или вновь инициализировать существующий можно параметром init. При инициализации он создаст скрытую папку. В ней содержатся все объекты и ссылки, которые Git использует и создаёт в истории работы над проектом.

**git init**

## Определение состояния файлов:

Команда **git status** отображает все файлы, которые различаются между тремя разделами. У файлов есть 4 состояния:

**Неотслеживаемый (untracked)** — находится в рабочей директории, но нет ни одной версии в HEAD или в области подготовленных файлов (Git не знает о файле).
**Изменён (modified)** — в рабочей директории есть более новая версия по сравнению с хранящейся в HEAD или в области подготовленных файлов (изменения не находятся в следующем коммите).
**Подготовлен (staged)** — в рабочей директории и области подготовленных файлов есть более новая версия по сравнению с хранящейся в HEAD (готов к коммиту).
Без изменений — одна версия файла во всех разделах, т. е. в последнем коммите содержится актуальная версия.
Основной инструмент, используемый для определения, какие файлы в каком состоянии находятся — это команда :

**git status**

Файл может быть одновременно в состоянии «изменён» и «подготовлен», если версия в рабочей директории новее, чем в области подготовленных файлов, которая в свою очередь новее версии в HEAD. Мы можем использовать опцию -s для команды git status, чтобы получить более компактный вывод (по строке на файл). Если файл не отслеживается, то будет выведено что он не отслеживается; если он был изменён, то его имя будет красным, а если подготовлен — зелёным.

Для того чтобы начать отслеживать (добавить под версионный контроль) новый файл:

**git add**

**git add .** --> добавить в индекс все новые, изменённые, удалённые файлы из текущей директории и её поддиректорий

**git add -A или git add --all**--> добавляем все измененные файлы в индекс:
Команда git add. Добавление новых изменений файла в индекс.

**Лучшая команда, которая заменяе введение add и commit это git commit -am "описание коммита"**

## Удаление файлов:

**git rm <имя файла>** - отменяет отслеживание файла и удаляет его из рабочей директории иными словами удаляет отслеживаемый неизменённый файл и проиндексирует это изменение

**git rm -f <имя файла>** - удалить отслеживаемый изменённый файл и проиндексировать это изменение

**git rm -r log/** - удалить всё содержимое отслеживаемой директории log/ и проиндексировать это изменение

__git rm ind*__ - удалить все отслеживаемые файлы с именем, начинающимся на «ind» в текущей директории и проиндексировать это изменение

**git rm --cached <имя файла>** - удалить из отслеживаемых индексированный файл (ФАЙЛ ОСТАНЕТСЯ НА МЕСТЕ) (часто используется для нечаянно добавленных в отслеживаемые файлов)

## Восстановление файлов после удаления:

Если мы захотим восстановить файл после удаления или изменения в рабочей копии или индексе - для этого существует команда git restore.

**git restore <ключ> <имя файла>**

Ключи -s, --source= --> Этот ключ нужен, чтобы передать команде путь к коммиту (ветке, пользовательскому указателю), откуда мы будем восстанавливать файл. По умолчанию файл берется из области индекса.

--worktree (англ. рабочая копия) --staged (англ. область индекса)

Эти два ключа позволяют указать, где именно восстанавливать файл. По умолчанию, если ни один из этих двух ключей не передан, файл восстанавливается только в рабочей копии.

Если же передан ключ --staged, файл восстанавливается только в области индекса. В этом случае источником восстановления по умолчанию является коммит, на который указывает HEAD (поскольку мы не можем восстановить файл в области индекса из самой же области индекса).

Если же вы хотите восстановить файл и в рабочей копии, и в области индекса, вам нужно передать оба ключа.

Если вы случайно удалили файл sample.txt обычным способом, то можно восстановить его из индекса --> git restore sample.txt

Вернем файл sample.txt к определенному коммиту с хэшем 1234. При этом мы изменим только файл в рабочей копии, файл в области индекса не поменяется. --> git restore --source 1234 sample.txt

Вернем файл sample.txt в индексе к состоянию последнего коммита (отменим все внесенные изменения или удалим файл, если в предыдущем коммите его не было), при этом изменения коснутся только индекса файла, рабочая копия не поменяется. --> git restore --staged sample.txt

Сделаем то же, что и в предыдущем примере, но теперь изменения затронут и файл в рабочей копии. --> git restore --staged --worktree sample.txt

## Игнорирование файлов:

Зачастую, у вас имеется группа файлов, которые вы не только не хотите автоматически добавлять в репозиторий, но и видеть в списках неотслеживаемых. К таким файлам обычно относятся автоматически генерируемые файлы (различные логи, результаты сборки программ и т. п.). В таком случае, вы можете создать файл c названием .gitignore. с перечислением шаблонов соответствующих таким файлам. Для сопоставления с именами файлов в .gitignore используются шаблоны подстановки. С помощью различных символов можно создавать собственные шаблоны. Чтобы отметить файлы, которые мы хотим игнорировать, можно использовать эти шаблоны поиска (считайте их упрощёнными регулярными выражениями):

/___ — позволяет избежать рекурсивности — соответствует файлам только в текущей директории;
__/ — соответствует всем файлам в указанной директории;
___ — соответствует всем файлам с указанным окончанием;
! — игнорирование файлов, попадающих под указанный шаблон;
[__] — соответствует любому символу из указанных в квадратных скобках;
? — соответствует любому символу;
/**/ — соответствует вложенным директориям, например a/**/d соответствует a/d, a/b/d, a/b/c/d и т. д. Мы даже можем использовать шаблоны поиска при указании файла/папки в других командах. Например, git add src/*.css добавит все файлы .css в папке src.

## Внесение изменений однострочным сообщением или через редактор - git commit:

Команда **git commit** откроет текстовый редактор для ввода сообщения коммита. Также эта команда принимает несколько аргументов:

-m позволяет написать сообщение вместе с командой, не открывая редактор. git commit -m "Залил фотку Тефтельки"

-a переносит все отслеживаемые файлы в область подготовленных файлов и включает их в коммит (позволяет пропустить git add перед коммитом); git commit -a "Залил фотку Тефтельки"

--amend заменяет последний коммит новым изменённым коммитом, что бывает полезно, если вы неправильно набрали сообщение последнего коммита или забыли включить в него какие-то файлы. git commit --amend -m "Залил фотку Тефтельки - я молодец!"

Коммиты хранят состояние файловой системы в определённый момент времени и указатели на предыдущие коммиты. Каждый коммит содержит уникальную контрольную сумму — идентификатор, который Git использует, чтобы ссылаться на коммит. Чтобы отслеживать историю, Git хранит указатель HEAD, который указывает на первый коммит (мы следуем по цепочке коммитов в обратном порядке, чтобы попасть к предыдущим коммитам). 

Коммитьте как можно чаще.

Одно изменение — один коммит: не помещайте все не связанные между собой изменения в один коммит, разделите их, чтобы было проще откатиться.

Формат сообщений: заголовок должен быть в повелительном наклонении, меньше 50 символов в длину и должен логически дополнять фразу this commit will ___(this commit will fix bugs — этот коммит исправит баги). Сообщение должно пояснять, почему был сделан коммит, а сам коммит показывает, что изменилось.

Если у вас много незначительных изменений, хорошим тоном считается делать небольшие коммиты при разработке, а при добавлении в большой репозиторий объединять их в один коммит.

Просмотр истории коммитов с изменениями
Просматривать изменения, внесённые в репозиторий, можно с помощью параметра log. Он отображает список последних коммитов в порядке выполнения. Кроме того, добавив флаг -p, вы можете подробно изучить изменения, внесённые в конкретный файл.

**git log** - общий журнал всех изменений

git log -p имя файла.расширение - список изменений для внесённых в конкретный файл.

git log --graph - история в виде дерева (Выводит коммиты в виде дерева, в командной строке псевдографикой. Плюс выводит список измененных файлов.)

**git log --oneline**- выводит журнал форме короткого списка c комметариями коммитов и хешем из первых 7 символов Это очень полезная команда

можно git log -7 (покажет 7 последних коммитов).

git log --pretty=oneline develop(откуда)..feature(где) (можно посмотреть все коммиты от отдой до другой ветки), 

git log --all --pretty=oneline --graph 

git log --pretty=oneline --graph main..new_feature (между названиями веток обязательно 2 точки)
## Просмотр коммита:

Просмотреть полный список изменений, внесённых конкретным коммитом, можно с помощью параметра show, указав идентификатор или хеш коммита. Значение хеша уникально для каждого коммита, созданного в вашем репозитории.

**git show 1af17e73721dbe0c40011b82ed4bb1a7dbe3ce29**
Также можно использовать сокращённый хеш:

git show 1af1

Для переключения на нужный коммит
Используется действие **checkout**.После переключения, все файлы в проекте станут такими, какими они были в данном коммите.

**git checkout commit**

Где commit - это хеш (обозначение, имя) коммита, причем можно указывать не весь хеш, а несколько начальных символов хеша (4 первых символа как правило достаточно)

**Возвращаемся к основной ветке**

**git checkout master or git checkout main**

git checkout HEAD~^2~2 (~переносит HЕAD назад ^позволяет переключиться на праводителся ветки после merge)

## Сравнение с последним коммитом

Для вывода изменений в файлах по сравнению с последним коммитом, используется **git diff** без параметров Команда выводит изменения в файлах, которые еще не были добавлены в индекс. Сравнение происходит с последним коммитом.

Можно сравнить любые коммиты между собой, отделив их двумя точками

git diff <1234хэша>..<1234хэша>


## Ветвления:

Ветка – независимая последовательность коммитов. Ветки нужны, чтобы тестировать новые функции и распараллеливать работу над проектом. Первоначально мы работаем в основной ветке. У нас она называется main. Обычно в основной ветке находится та же версия кода, что и в продакшене. То есть если в основную ветку попадут какие-то непроверенные изменения, код может сломаться и повлечь за собой поломку приложения у конечного пользователя. Поэтому во всех командах, работающих над серьезными проектами, принято, что в основной ветке находятся только протестированные изменения, которые в идеале не придется экстренно исправлять.

То есть общий ход нашей работы выглядит следующим образом:

Решили добавить новую функцию – создали отдельную ветку. Дальше работаем в новой ветке.
Написали функцию, протестировали ее работу, внесли все необходимые исправления, еще раз протестировали и убедились, что функция работает исправно и не привнесла ошибок в остальной код.
Теперь нужно как-то перенести изменения с тестовой ветки на основную – в продакшн. Тут нам на помощь и приходит слияние: мы просто сливаем (т.е. переносим) изменения с нашей тестовой ветки в основную.
Создание ветки:

**git branch Имя_ветки**

Переключение между ветками:
**git checkout Имя_ветки**

Создание ветки и сразу переключение на неё:
**git checkout –b Имя_ветки**

Переименование ветки:
git branch –m Старое_название_ветки Новое_название_ветки

Удаление ветки:
Удалить ветку можно параметром branch с добавлением флага -d и указанием имени ветки. Если вы завершили работу над веткой и объединили её с основной, можно её удалить без потери истории. Однако, если выполнить команду удаления до слияния — в результате появится сообщение об ошибке. Этот защитный механизм предотвращает потерю доступа к файлам.

git branch –d Имя_ветки

Для принудительного удаления ветки используется флаг -D с заглавной буквой. В этом случае ветка будет удалена независимо от текущего статуса, без предупреждений.

git branch –D Имя_ветки

Алгоритм cлияния веток:
Переключиться на ветку, в которой будут приняты изменения:
git checkout Имя_ветки

Указать ветку, в которой будут приняты изменения:
git merge ветка_с_нужными_изменениями

## Конфликты:

Для того, чтобы выяснить, в каких файлах есть конфликты, нужно набрать Git команду: git status Все, что находится в HEAD - это наши изменения, и все, что находится после знаков равно (======)- это внешние изменения.

Нужно выбрать, какие изменения оставить.

После того как решите конфликты, нужно использовать Git команду: git commit

Прекращение слияния веток при конфликте
Прервать слияние в случае конфликта можно параметром merge с флагом --abort. Он позволяет остановить процесс слияния и вернуть состояние, с которого этот процесс был начат.

**git merge --abort**

## Откат коммитов. 

Команда **git revert**.
Пожалуй одна из самых важных частей в изучении Git – научиться откатываться к предыдущим коммитам. Смысл отката мы обсуждали в предыдущих уроках: ваш проект может перестать работать по непонятным вам причинам после внесения некоторых изменений в код, в таком случае важно быстро вернуть все к рабочему состоянию и только потом заниматься поиском ошибки. В этом-то случае нам и поможет откат коммитов и команда git revert.Все коммиты, которые уже были отправлены в удалённый репозиторий, должны отменяться новыми коммитами (git revert), дабы избежать проблем с историей разработки у других участников проекта.

git revert HEAD  --> создать новый коммит, отменяющий изменения последнего коммита 
git revert HEAD --no-edit --> создать новый коммит, отменяющий изменения последнего коммита без запуска редактора сообщения

git revert b9533bb --no-edit --> то же что и выше, но отменяются изменения, внесённые коммитом с указанным хешем (b9533bb)

git revert HEAD~2 --> отменяются изменения, внесенные 2 коммита назад

git revert HEAD5..HEAD2 --> отменяются изменения, начиная с пятого с конца и заканчивая вторым с конца.

Разница между revert и reset

Команда git revert отменяет изменения, записанные только одним коммитом. Она не откатывает проект к более раннему состоянию, удаляя все последующие коммиты, как это делает команда git reset.

У команды revert есть два крупных преимущества по сравнению с reset. Во-первых, она не меняет историю проекта и производит операцию, безопасную для коммитов. Во-вторых, её объектом выступает конкретный коммит, созданный в любой момент истории, а git reset всегда берёт за точку отсчёта текущий коммит. К примеру, если нужно отменить старый коммит с помощью git reset, придётся удалить все коммиты, поданные после целевого, а затем выполнить их повторно. Следовательно, команда git revert — гораздо более удобный и безопасный способ отмены изменений.

Откат заданного коммита
Откатить проект до заданного коммита можно с помощью параметра revert и идентификатора коммита. Создастся новый коммит — копия коммита с предоставленным идентификатором — и добавится к истории текущей ветки.

git revert добавляем сюда хэш

3 режима команды git reset: --soft, --mixed(по умолчанию), --hard)
Сделанные изменения в репозитории по умолчанию имеют статус unstaged. Для того чтобы их закоммитить сначала вы должны добавить изменения в индекс, выполнив git add. Когда вы делаете git commit, в репозиторий будет закоммичено только то, что было в индексе.

git reset --soft

Возьмем для примера ветку:

A - B - C (master) HEAD указывает на C и индекс совпадает с C.
После выполнения git reset --soft B HEAD будет указывать на B и изменения из коммита C будут в индексе, как будто вы их добавили командой git add. Если вы сейчас выполните git commit вы получите коммит полностью идентичный C.

git reset --mixed (используется по умолчанию)

Режим --mixed используется по умолчанию, т.е. git reset --mixed = git reset

Вернемся к тем же начальным условиям:

A - B - C (master)
Выполнив git reset --mixed B или git reset B

HEAD опять же будет указывать на B, но на этот раз изменения из С не будут в индексе и если вы запустите здесь git commit ничего не произойдет т.к. ничего нет в индексе. У нас есть все изменения из С, но если запустить git status то вы увидите, что все изменения not staged. Чтобы их закоммитить нужно сначала добавить их в индекс командой git add и только после этого git commit.

git reset --hard

Те же самые начальные условия:

A - B - C (master)
Последний режим --hard также как и --mixed переместит HEAD на В и очистит индекс, но в отличие от --mixed жесткий reset изменит файлы в вашей рабочей директории. Если выполнить git reset --hard B то изменения из С, равно как и незакоммиченные изменения, будут удалены и файлы в репозитории будут совпадать с B. Учитывая то, что этот режим подразумевает потерю изменений, вы всегда должны проверять git status перед тем как выполнить жесткий reset чтобы убедиться что нет незакоммиченных изменений (или же они не нужны).

Это значит что:

Действие команды git reset <коммит> состоит из трёх потенциальных шагов:

Переместить указатель HEAD на <коммит> (например, при откате коммита в рабочей директории и области подготовленных файлов будут более новые версии файлов, чем в HEAD). Также указатель HEAD ветки будет перемещён на этот коммит.

Обновить область подготовленных файлов содержимым коммита. В таком случае только в рабочей директории будут новейшие версии файлов.

Обновить рабочую директорию содержимым области подготовленных файлов. С этим нужно быть осторожнее, поскольку в итоге будут уничтожены изменения файлов.

По умолчанию команда git reset выполняет только шаги 1 и 2, однако её поведение можно изменить с помощью опций --soft (только 1 шаг) и --hard (все шаги).


git reset HEAD~1 *удаляет последний коммит на локальном репозитории*


## Команды на всякий случай

сlear *позволяет очистить поле*

Q *если всё висит и ничего не помогает, если закончилось поле для текста в терминале*


git tag v1 c1 *ставит метку (тег) на интересующий коммит*

git tag v1 *поставит тэг на HEAD*

git describe ветка (она выходе название тега, склько до него, последний хэш ветки)

git cherry-pick <commit1> <commit2> *копирует коммиты на HEAD только не с предка HEAD*

## Командная работа с репозиториями

Удалённые репозитории --> GitHub

Чтобы воспользоваться сервисом, нужно зайти на сайт [GitHub](https://github.com/) и зарегистрировать нового пользователя. Придумайте имя и пароль, а также введите e-mail, к которому у вас есть доступ:


Не забудьте верифицировать аккаунт: откройте первое письмо на почте от GitHub и пройдите по ссылке. Иначе вы не сможете создавать репозитории.

Теперь, когда у вас есть свой аккаунт, нужно залогиниться в самой консоли (привет, любимый терминал!), чтобы связать их. Для этого понадобится выполнить команды в консоли, которые зададут имя пользователя и почтовый ящик.

git config --global user.name "user-name"

git config --global user.email "email@example.com"

Вместо user-name подставьте логин, который указывали при регистрации. В случае на скриншоте это test-github-04, а вместо email@example.com — адрес вашей электронной почты. В данном примере — testgithub@gmail.com.

Если вы всё сделали по инструкции, то при выполнении команды git config --list отобразится ваше имя пользователя и e-mail

Если на момент регистрации акаунта на GitHub вы уже настроили и установили сам Git и при этом Вы уже внесли какие-то данные - не переживайте, просто воспользуйтесь выше указанными командами и обновите имя пользователя и e-mail используя новые данные которые вы вносили при регистрации на GitHub

Как опубликовать первый проект на GitHub:
Зайдите в ваш профиль: для этого кликните по иконке в правом верхнем углу и нажмите Your Profile

Теперь создайте репозиторий: перейдите во вкладку Repositories и кликните по кнопке New

Задайте имя репозитория. На скриншоте название проекта test-github и он сделан публичным, чтобы его могли просматривать все пользователи. Далее нажмите кнопку: Create repository

Пока проект пустой, но мы можем поместить в него наши файлы с нашего компьютера.

Чаще всего используют протокол HTTPS — с ним проще работать с Git, чем с SSH.

Подробнее про различия протоколов можно прочитать в приложенной к данному проекту документации: см. стр.109

Github предлагает несколько вариантов действий при создании проекта:

Клонировать папку нашего проекта согласно выбранному протоколу HTTPS либо SSH
Создать абсолютно новый проект с нуля
Опубликовать на GitHub уже созданный "локальный" проект размещенный на компьютере.
Скопировать и импортировать на GitHub чей-то проект из другого репозитория
Давайте разбираться что все это собственно значит :-)

## Что же такое клонирование?

Это копирование удаленного репозитория на локальную машину. Обычно это первое действие при работе с проектом. При клонировании на нашу машину копируются файлы и папки проекта и вся его история. То есть мы получаем доступ к истории не с момента начала нашей работы над проектом, а с самого начала проекта.

Как клонировать готовый проект?

В первую очередь, нужно получить ссылку на проект. Мы можем найти ее сами или получим готовую.

При клонировании в текущем каталоге создастся папка, в ней окажутся все файлы проекта и специальная скрытая папка .git, то есть сам репозиторий, или информация о нем. 
При использовании команды **git clone <url репозитория>** мы не только загружаем себе копию репозитория, но и неявно отслеживаем удалённый сервер, который находится по указанному адресу и которому присваивается имя origin.

## Создание проекта на GitHub с нуля:

При помощи команды cd нужно найти нужную папку

Поэтапно следуем командам которые предлагает нам GitHub:

echo "# YourRepositoryName" >> README.md
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin https://github.com/YourGitHubName/YourRepositoryName.git
git push -u origin main
1-ая команда:

echo "# YourRepositoryName" >> README.md добавляет новый файл в проект.

Его также можно создать вручную в папке

2-ая команда:

git init — инициализирует проект.

После инициализации создаётся специальная скрытая папка для Git:

Тут необходимо заглянуть сюда для пояснения ряда команд на скриншотах.

3-ая команда: git add README.md — добавляет изменённые файлы к коммиту Также это можно сделать при помощи команды git add . — в таком случае вы добавите не конкретные файлы, а все изменённые, если их много. git status поможет проверить, что происходит с изменёнными файлами. В нашем случае, например, файлы не прикреплены к коммиту

4-ая команда:

git commit -m "first commit" добавляет сообщение к коммиту — то, что будет отображаться в истории Теперь снова посмотрим, что скажет git status. Сейчас он пустой, так как все изменённые файлы мы прикрепили к только что созданному коммиту

5-ая команда:

git branch -M main переименовывает ветку в main В нашем примере текущая ветка называется master. Но с 2020 года GitHub выступает за то, чтобы главная ветка называлась main (по политическим причинам) и рекомендует переименовать ветку с помощью команды git branch -M main.

В скобках можно указать любой текст. Как правило, в нём кратко описывают, что делали в коммите. Теперь снова посмотрим, что скажет git status. Сейчас он пустой, так как все изменённые файлы мы прикрепили к только что созданному коммиту

6-ая команда:

Получаем такой результат

Команда git remote add origin https://github.com/YourGitHubName/YourRepositoriyName.git добавляет сервер, где origin — это имя сервера, а url — это адрес. У вас может быть несколько удалённых серверов, с которыми работает проект. Проверить добавленные сервера можно командой git remote -v (fetch — откуда забирать, push — куда отправлять изменения).

7-ая команда:

git push -u origin main позволяет запушить (отправить) ветку main на сервер origin

Тут вам, скорее всего, потребуется связать приложение и GitHub, повторно залогинившись через браузер.

Опубликовать на GitHub уже существующий "локальный" проект (размещенный на компьютере) с помощью терминала:
"push an existing repository from the command line"

Предполагается, что вы создали свой репозиторий на GitHub, и в настоящее время он пуст. Наш локальный проект на компьютере может размещается в любом каталоге. Для него нужно инициализировать git. Это стандартная процедура: git init + git add . + git commit -m "Initinal commit"

Поэтапно следуем командам которые предлагает нам GitHub:

1-ая команда:

git remote add origin https://github.com/YourGitHubName/YourRepositoriyName.git

Для связи с GitHub указали удаленный репозиторий.

Адрес на сайте Github

2-ая команда:

git branch -M main

Переименовываем главную ветку в main

3-ая команда:

git push -u origin main

Отправляем все изменения на сервер GitHub. Если мы теперь зайдем на страницу репозитория на GitHub, то увидим свой проект.

## Импортировать код из какого-то другого репозитория в свой:

Жмём кнопку Import Code

Вставляем ссылку на репозиторий который хотим импортировать и нажимаем Begin import

Ждём когда процесс импорта закончится

## Наиболее употребляемые команды для работы с удалёнными репозиториями:

**git remote -v** выводит список удалённых репозиториев, которые мы отслеживаем, и имена, которые мы им присвоили.

**git remote add <имя>** — добавляет удалённый репозиторий с заданным именем;

**git remote remove <имя>** — удаляет удалённый репозиторий с заданным именем;

**git remote rename <старое имя> <новое имя>** — переименовывает удалённый репозиторий;

**git remote set-url <имя>** — присваивает репозиторию с именем новый адрес;

**git remote show <имя>** — показывает информацию о репозитории.

### Следующие команды работают с удалёнными ветками:

**git fetch <имя> <ветка>** — получает данные из ветки заданного репозитория, но не сливает изменения;

**git pull <имя> <ветка>** — сливает данные из ветки заданного репозитория;

**git push <имя> <ветка>** — отправляет изменения в ветку заданного репозитория. Если локальная ветка уже отслеживает удалённую, то можно использовать просто git push или git pull.

Команда git pull отвечает за скачивание данных с сервера. Процесс очень похож на клонирование репозитория, но здесь скачиваются не все коммиты, а только новые.

По сути, git pull — это сочетание команд git fetch (загружает коммиты, ссылки, файлы из удаленного репозитория в локальный) и git merge (объединяет несколько коммитов в один общий). Команда git merge связывает ряд коммитов в одно целое. В свою очередь git создает коммит слияния, где и объединяются изменения обеих последовательностей.

На первой стадии git pull выполняется команда fetch, ограниченная локальной веткой. Затем команда git pull выполняет слияние и формируется новый коммит.

## Создание ответвлений (fork)

Если вы хотите вносить свой вклад в уже существующие проекты, в которых у нас нет прав на внесения изменений путём отправки (push) изменений, вы можете создать своё собственное ответвление (fork) проекта. Это означает, что GitHub создаст вашу собственную копию проекта, данная копия будет находиться в вашем ведении и вы сможете легко делать изменения путём отправки (push) изменений.

Шаг 1-ый: для того, чтобы создать ответвление проекта, зайдите на страницу проекта на GitHub и нажмите кнопку «Создать ответвление» («Fork»),нажимаем кнопку которая расположена в правом верхнем углу.

Шаг 2-ой: клонируйте проект на свою машину Перейдите в свой "форк" репозитория (который теперь находится в ваших репозиториях GitHub).Затем клонируйте проект на свой компьютер, введя в окне вашего терминала:git clone <скопированный-адрес> Переходим в клонированную директорию:cd [имя репозитория] Для того, чтобы работать внутри созданного каталога, в него требуется перейти командой cd name. Это справедливо и при клонировании удалённого репозитория с помощью команды git clone <скопированный-адрес>. Полностью склонированный репозиторий создаст каталог в текущей директории с именем проекта, в который нужно перейти командой cd <имя репозитория> Например: https://github.com//ShafigullinIK/group_903.git - наш проект от которого мы взяли fork. После клонирования и применения git init мы видим папку: group_903 в нашей папке Test которую мы предварительно создали, однако терминал нам говорит когда мы спрашиваем где мы собственно сейчас (команда pwd), что мы в папке TEST, но не group_903 где находится наш репозиторий и куда нам нужно поэтому используем команду cd group_903/ Для более детального ознакомления с командами Git по работе с дерикториями через терминал тык сюда

Шаг 3-ий: создание upstream Вам нужно отслеживать разницу между вашим "форком" репозитория в вашем аккаунте на GitHub и оригинальным репозиторием. Это особенно полезно, если вы хотите принять участие в работе над каким-то популярным репозиторием. Некоторые репозитории делают слияние "пул-реквестов" каждый час или даже чаще, так что вам нужно следить за тем, чтобы ваш форк не отставал от оригинального репозитория. В этом вам поможет upstream - "верхнее течение" c английского языка. Для создания ссылки на оригинальный репозиторий введите в терминале следующую команду: 
**git remote add upstream <скопированный-адрес-upstream>** (скопированный-адрес-upstream это оригинального репозитория от которого мы делали ответвление, а не сам форк) Визуально это выглядит вот так

Далее можно выполнить команду **git pull upstream master** чтобы убедиться, не произошло ли каких-то изменений (с того момента как вы сделали форк и до настоящей минуты).

Шаг 4-ый: создание отдельной новой ветки (branch), над которой вы будите работать. Когда вы хотите что-либо изменить в проекте, будет хорошей идеей создать для этих изменений отдельную ветку. Это будет демонстрировать, что ветка предназначена только для той работы, которую вы хотите сделать. Такой работой может быть и исправление опечатки, и реализация новой фичи. В любом случае, будет хорошим тоном создать новую ветку. Также имеет значение присвоение имён. Будет любезно с вашей стороны использовать имя, которое легко сможет понять человек, ничего не знающий об этом репозитории. Например, если вы хотите добавить возможность логиниться в приложении, можно создать ветку под названием new_branch_for_login_feature Для создания ветки введите в терминале следующую команду:git checkout -b new_branch Будет создана ветка и сразу осуществлен переход в нее. После этого можно начинать вносить свои изменения в ветку (исправлять опечатку, писать код фичи и т. д.).

Шаг 5: Git add и commit изменений Это тоже достаточно просто. Вам нужно подготовить ваши изменения и сделать коммит (запись изменений), введя следующие команды в терминале: git add . + git commit -m 'Сообщение коммита' Теперь ваши изменения подготовлены и записаны в ваш репозиторий.

Шаг 6: pull (получение данных) из upstream в вашу ветку Этот шаг сольет (merge) любые изменения, произошедшие в upstream (оригинальном репозитории), с вашей веткой, чтобы избежать конфликтов. git pull upstream <имя-ветки над которой вы работаете>

Шаг 7: push (помещение данных) в ветку, в которой вы работаете Все почти готово. «Пушим» изменения в свою рабочую ветку:git push origin <имя-ветки над которой вы работаете>

Шаг 8: нажимаем contribute -> open pull request на GitHub

Это финальный шаг, который делает контрибутор open source проекта. На этом этапе вы будто говорите: «Я внес некоторые изменения, не будете ли вы так любезны добавить их в проект?» Вы открываете pull request, и если собственнику репозитория или людям, занимающимся его поддержкой, ваши изменения понравятся, они сольют их со своим проектом (merge). Также они могут внести какие-то изменения, а уж затем выполнить слияние, или запросить эти изменения. Для открытия pull request перейдите в ваш fork репозитория, как показано ниже. Вы увидите последнюю ветку, в которую вы делали push. Кликните на «compare and pull request». Четко поясните, что именно вы изменили, и создайте pull request

Комментарии очень важны: присвойте имя и сделайте описание максимально чётким лаконичным и ёмким!

## Создание комментариев для pull request

В конечном счёте владелец проекта которому прислали pull request может либо принять предлагаемые изменения - кнопка: **confirm merge** либо же отклонить - кнопка: **close pull request**.

Именно благодаря наличию системы комментариев отсеивается огромное количество конфликтов и багов... 

# Источники:

[Шпаргалка по GIT](https://github.com/cyberspacedk/Git-commands)

[онлайн бесплатный курс по GIT и Github из 6 уроков](https://smartiqa.ru/courses/git)

[данные после игры на learningbranching]

![Happy ending](after_work.jpg)